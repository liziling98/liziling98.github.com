<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kafka,">










<meta name="description" content="kafka一般被称为“分布式提交日志”或者“分布式流平台”，它是一款一款基于发布与订阅的消息系统 background 消息和批次  Kafka的数据单元被称为消息，可以把消息看成是数据库里的一个“数据行”或一条“记录”，为了提高效率，消息被分批次写入 Kafka。批次就是一组消息，这些消息属于同一个主题和分区。  主题和分区  Kafka 的消息通过主题进行分类。主题就好比数据库的表，或者文件系">
<meta name="keywords" content="kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="kafka学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/12/31/2019-12-31-kafka学习笔记/index.html">
<meta property="og:site_name" content="李子泠">
<meta property="og:description" content="kafka一般被称为“分布式提交日志”或者“分布式流平台”，它是一款一款基于发布与订阅的消息系统 background 消息和批次  Kafka的数据单元被称为消息，可以把消息看成是数据库里的一个“数据行”或一条“记录”，为了提高效率，消息被分批次写入 Kafka。批次就是一组消息，这些消息属于同一个主题和分区。  主题和分区  Kafka 的消息通过主题进行分类。主题就好比数据库的表，或者文件系">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-01-15T12:17:02.971Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kafka学习笔记">
<meta name="twitter:description" content="kafka一般被称为“分布式提交日志”或者“分布式流平台”，它是一款一款基于发布与订阅的消息系统 background 消息和批次  Kafka的数据单元被称为消息，可以把消息看成是数据库里的一个“数据行”或一条“记录”，为了提高效率，消息被分批次写入 Kafka。批次就是一组消息，这些消息属于同一个主题和分区。  主题和分区  Kafka 的消息通过主题进行分类。主题就好比数据库的表，或者文件系">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/31/2019-12-31-kafka学习笔记/">





  <title>kafka学习笔记 | 李子泠</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李子泠</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/2019-12-31-kafka学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李子泠">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子泠">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">kafka学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-31T00:00:00+08:00">
                2019-12-31 00:00:00
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-15T20:17:02+08:00">
                2020-01-15 20:17:02
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据/" itemprop="url" rel="index">
                    <span itemprop="name">数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>kafka一般被称为“分布式提交日志”或者“分布式流平台”，它是一款一款基于发布与订阅的消息系统</p>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><ol>
<li>消息和批次</li>
</ol>
<p>Kafka的数据单元被称为消息，可以把消息看成是数据库里的一个“数据行”或一条“记录”，为了提高效率，消息被分批次写入 Kafka。批次就是一组消息，这些消息属于同一个主题和分区。</p>
<ol start="2">
<li>主题和分区</li>
</ol>
<p>Kafka 的消息通过主题进行分类。主题就好比数据库的表，或者文件系统里的文件夹。主题可以被分为若干个分区，一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。</p>
<ol start="3">
<li>生产者和消费者</li>
</ol>
<p>Kafka 的客户端就是 Kafka 系统的用户，它们被分为两种基本类型：生产者和消费者</p>
<p>生产者创建消息。在其他发布与订阅系统中，生产者可能被称为发布者或写入者。一般情况下，一个消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产者会把消息直接写到指定的分区。这通常是通过消息键和分区器来实现的，分区器为键生成一个散列值，并将其映射到指定的分区上。这样可以保证包含同一个键的消息会被写到同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分区。</p>
<p>消费者读取消息。在其他发布与订阅系统中，消费者可能被称为订阅者或读者。消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。消费者通过检查消息的偏移量来区分已经读取过的消息。偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时，Kafka 会把它添加到消息里。在给定的分区里，每个消息的偏移量都是唯一的。消费者把每个分区最后读取的消息偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失。</p>
<p>消费者是消费者群组的一部分，也就是说，会有一个或多个消费者共同读取一个主题。群组保证每个分区只能被一个消费者使用。</p>
<ol start="4">
<li>broker和集群</li>
</ol>
<p>一个独立的 Kafka 服务器被称为 broker。broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。</p>
<p>broker 是集群的组成部分。每个集群都有一个 broker 同时充当了集群控制器的角色（自动从集群的活跃成员中选举出来）。控制器负责管理工作，包括将分区分配给 broker 和监控broker。在集群中，一个分区从属于一个 broker，该 broker 被称为分区的首领。</p>
<p>在一定期限内保留消息是kafka的一个重要特性。Kafka broker 默认的消息保留策略是这样的：要么保留一段时间（比如 7 天），要么保留到消息达到一定大小的字节数（比如 1GB）。主题可以配置自己的保留策略，可以将消息保留到不再使用它们为止。</p>
<ol start="5">
<li>多集群</li>
</ol>
<p>随着 Kafka 部署数量的增加，基于以下几点原因，最好使用多个集群：</p>
<pre><code>数据类型分离
安全需求隔离
多数据中心（灾难恢复）</code></pre><ol>
<li><p>使用场景</p>
<p> 活动跟踪<br> 传递消息<br> 度量指标和日志记录<br> 提交日志<br> 流处理</p>
</li>
</ol>
<h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><h4 id="生产者概览"><a href="#生产者概览" class="headerlink" title="生产者概览"></a>生产者概览</h4><p>一个应用实例：<br>    在一个信用卡事务处理系统里，有一个客户端应用程序，它可能是一个在线商店，每当有支付行为发生时，它负责把事务发送到 Kafka 上。另一个应用程序根据规则引擎检查这个事务，决定是批准还是拒绝。批准或拒绝的响应消息被写回 Kafka，然后发送给发起事务的在线商店。第三个应用程序从 Kafka 上读取事务和审核状态，把它们保存到数据库，随后分析师可以对这些结果进行分析，或许还能借此改进规则引擎。</p>
<p>一个应用程序在很多情况下需要往 Kafka 写入消息：记录用户的活动（用于审计和分析）、记录度量指标、保存日志消息、记录智能家电的信息、与其他应用程序进行异步通信、缓冲即将写入到数据库的数据，等等。</p>
<p>我们从创建一个 ProducerRecord 对象开始，ProducerRecord 对象需要包含目标主题和要发送的内容。我们还可以指定键或分区。在发送 ProducerRecord 对象时，生产者要先把键和值对象序列化成字节数组，这样它们才能够在网络上传输。</p>
<p>接下来，数据被传给分区器。如果之前在 ProducerRecord 对象里指定了分区，那么分区器就不会再做任何事情，直接把指定的分区返回。如果没有指定分区，那么分区器会根据ProducerRecord 对象的键来选择一个分区。选好分区以后，生产者就知道该往哪个主题和分区发送这条记录了。紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的broker 上。</p>
<p>服务器在收到这些消息时会返回一个响应。如果消息成功写入 Kafka，就返回一个RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。</p>
<h4 id="创建kafka生产者"><a href="#创建kafka生产者" class="headerlink" title="创建kafka生产者"></a>创建kafka生产者</h4><p>第一步，创建生产者对象，kafka生产者有3个必选的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. bootstrap.servers</span><br><span class="line">该属性指定broker的地址清单，地址的格式为host:port。清单里不需要包含所有的broker地址，生产者会从给定的broker里查找到其他broker的信息。不过建议至少要提供两个broker的信息，一旦其中一个宕机，生产者仍然能够连接到集群上。</span><br><span class="line"></span><br><span class="line">2. key.serializer</span><br><span class="line">broker 希望接收到的消息的键和值都是字节数组。生产者接口允许使用参数化类型，因此可以把 Java 对象作为键和值发送给 broker</span><br><span class="line">key.serializer 必须被设置为一个实现了org.apache.kafka.common.serialization.Serializer 接口的类，生产者会使用这个类把键对象序列化成字节数组</span><br><span class="line"></span><br><span class="line">3. value.serializer</span><br><span class="line">与 key.serializer 一样，value.serializer 指定的类会将值序列化。如果键和值都是字符串，可以使用与 key.serializer 一样的序列化器。如果键是整数类型而值是字符串，那么需要使用不同的序列化器</span><br></pre></td></tr></table></figure>

<p>如何创建一个新的生产者（以下代码只指定了必要的属性），即实例化生产对象，完成后可以开始发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 Properties 对象</span></span><br><span class="line"><span class="keyword">private</span> Properties kafkaProps = <span class="keyword">new</span> Properties();</span><br><span class="line">kafkaProps.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内置的StringSerializer，把键和值定义成字符串类型</span></span><br><span class="line">kafkaProps.put(<span class="string">"key.serializer"</span>, </span><br><span class="line">  <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">kafkaProps.put(<span class="string">"value.serializer"</span>, </span><br><span class="line">  <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的生产者对象，并设置键和值的类型，然后把Properties对象传给它</span></span><br><span class="line">producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(kafkaProps);</span><br></pre></td></tr></table></figure>

<p>发送消息主要有以下3种方式</p>
<pre><code>1. 发送并忘记
2. 同步发送
3. 异步发送</code></pre><h4 id="发送消息到kafka"><a href="#发送消息到kafka" class="headerlink" title="发送消息到kafka"></a>发送消息到kafka</h4><p>举一个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建ProducerRecord对象，这是其中一个构造函数</span></span><br><span class="line"><span class="comment">// 需要目标主题的名字和要发送的键值对象，键值对象的类型必须与序列化器和生产者对象相匹配</span></span><br><span class="line">ProducerRecord&lt;String, String&gt; record = </span><br><span class="line">    <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// send()方法将ProducerRecord对象作为参数并发送</span></span><br><span class="line">    producer.send(record);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举一个同步发送消息的简单例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = </span><br><span class="line">    <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// producer.send() 方法先返回一个Future对象，然后调用Future对象的get()方法等待Kafka响应</span></span><br><span class="line">    <span class="comment">// 如果服务器返回错误，get() 方法会抛出异常</span></span><br><span class="line">    <span class="comment">// 如果没有发生错误，我们会得到一个 RecordMetadata 对象，可以用它获取消息的偏移量</span></span><br><span class="line">    producer.send(record).get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设消息在应用程序和 Kafka 集群之间一个来回需要 10ms。如果在发送完每个消息后都等待回应，那么发送 100 个消息需要 1 秒。但如果只发送消息而不等待响应，那么发送100 个消息所需要的时间会少很多。大多数时候，我们并不需要等待响应</p>
<p>为了在异步发送消息的同时能够对异常情况进行处理，生产者提供了回调支持。下面是使用回调的一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用回调，需要一个实现了 org.apache.kafka.clients.producer.Callback 接口的类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123; </span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录与之前的一样</span></span><br><span class="line">ProducerRecord&lt;String, String&gt; record = </span><br><span class="line">    <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Biomedical Materials"</span>, <span class="string">"USA"</span>); </span><br><span class="line"><span class="comment">// 在发送消息时传进去一个回调对象</span></span><br><span class="line">producer.send(record, <span class="keyword">new</span> DemoProducerCallback());</span><br></pre></td></tr></table></figure>

<h4 id="生产者的配置"><a href="#生产者的配置" class="headerlink" title="生产者的配置"></a>生产者的配置</h4><p>除了必备的参数外，还有很多可配置的参数，有一些参数再内存使用、性能和可靠性方面对生产者影响比较大，如下</p>
<ol>
<li>acks</li>
</ol>
<p>指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的</p>
<pre><code>acks=0，生产者再成功写入消息之前不会等待任何来自服务器的响应，可以达到很高的吞吐量
acks=1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。如果消息无法到达首领节点（比如首领节点崩溃，新的首领还没有被选举出来），生产者会收到一个错误响应，为了避免数据丢失，生产者会重发消息。这种情况下，同步发送会增加延迟，如果是异步发送，延迟问题会得到缓解，不过吞吐量还是会收到发送中消息数量的限制
acks=all，只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应，这种模式是最安全的，就算有服务器发生崩溃，整个集群仍然可以运行，但延迟最高</code></pre><ol start="2">
<li>buffer.memory</li>
</ol>
<p>用来设置生产者内存缓冲区的大小</p>
<ol start="3">
<li>compression.type</li>
</ol>
<p>默认情况下，消息发送时不会被压缩。该参数可以设置为 snappy、gzip 或 lz4，指定消息被发送给 broker 之前使用哪一种压缩算法进行压缩</p>
<ol start="4">
<li>retries</li>
</ol>
<p>生产者从服务器收到的错误有可能是临时性的错误（比如分区找不到首领）。在这种情况下，retries 参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误。默认情况下，生产者会在每次重试之间等待 100ms</p>
<ol start="5">
<li>batch.size</li>
</ol>
<p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。</p>
<ol start="6">
<li>linger.ms</li>
</ol>
<p>该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。把 linger.ms 设置成比 0 大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。虽然这样会增加延迟，但也会提升吞吐量</p>
<ol start="7">
<li>max.in.flight.requests.per.connection</li>
</ol>
<p>该参数指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量。把它设为 1 可以保证消息是按照发送的顺序写入服务器的，即使发生了重试。</p>
<ol start="8">
<li>request.timeout.ms</li>
</ol>
<p>指定了生产者在发送数据时等待服务器返回响应的时间</p>
<ol start="9">
<li>metadata.fetch.timeout.ms</li>
</ol>
<p>指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间</p>
<ol start="10">
<li>timeout.ms</li>
</ol>
<p>指定了 broker 等待同步副本返回消息确认的时间，与asks 的配置相匹配——如果在指定时间内没有收到同步副本的确认，那么 broker 就会返回一个错误</p>
<ol start="11">
<li>max.request.size</li>
</ol>
<p>该参数用于控制生产者发送的请求大小。它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息总的大小</p>
<ol start="12">
<li>receive.buffer.bytes 和 send.buffer.bytes</li>
</ol>
<p>这两个参数分别指定了 TCP socket 接收和发送数据包的缓冲区大小。如果它们被设为 -1，就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p>
<h4 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h4><p>如果发送到 Kafka 的对象不是简单的字符串或整型，那么可以使用序列化框架来创建消息记录，如 Avro、Thrift 或 Protobuf，或者使用自定义序列化器</p>
<p>如果用以下的类来表示一个客户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> customerID;</span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> ID, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerID = ID;</span><br><span class="line">        <span class="keyword">this</span>.customerName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customerID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为这个类创建一个序列化器，使用这个CustomerSerializer可以把消息记录定义成ProducerRecord&lt;String, Customer&gt;，并且可以直接把 Customer 对象传给生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.common.errors.SerializationException; </span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer; </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span>&lt;<span class="title">Customer</span>&gt; </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 不做任何配置 </span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    Customer对象被序列化成：</span></span><br><span class="line"><span class="comment">    表示customerID的4字节整数 </span></span><br><span class="line"><span class="comment">    表示customerName长度的4字节整数（如果customerName为空，则长度为0）</span></span><br><span class="line"><span class="comment">    表示customerName的N个字节 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String topic, Customer data) &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">byte</span>[] serializedName; </span><br><span class="line">        <span class="keyword">int</span> stringSize; </span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">if</span> (data.getName() != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    serializedName = data.getName().getBytes(<span class="string">"UTF-8"</span>); </span><br><span class="line">                    stringSize = serializedName.length; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    serializedName = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]; </span><br><span class="line">                    stringSize = <span class="number">0</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span> + <span class="number">4</span> + stringSize); </span><br><span class="line">            buffer.putInt(data.getID()); </span><br><span class="line">            buffer.putInt(stringSize); </span><br><span class="line">            buffer.put(serializedName); </span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> buffer.array(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Error when serializing Customer to byte[] "</span> + e); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; </span><br><span class="line">          <span class="comment">// 不需要关闭任何东西 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在Kafka里使用Avro"><a href="#在Kafka里使用Avro" class="headerlink" title="在Kafka里使用Avro"></a>在Kafka里使用Avro</h4><p>Avro的schema可能是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;namespace&quot;: &quot;customerManagement.avro&quot;, </span><br><span class="line"> &quot;type&quot;: &quot;record&quot;, </span><br><span class="line"> &quot;name&quot;: &quot;Customer&quot;, </span><br><span class="line"> &quot;fields&quot;: [ </span><br><span class="line">     &#123;&quot;name&quot;: &quot;id&quot;, &quot;type&quot;: &quot;int&quot;&#125;, </span><br><span class="line">     &#123;&quot;name&quot;: &quot;name&quot;,  &quot;type&quot;: &quot;string&quot;&#125;, </span><br><span class="line">     &#123;&quot;name&quot;: &quot;faxNumber&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;string&quot;], &quot;default&quot;: &quot;null&quot;&#125; ➊ </span><br><span class="line"> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Avro序列化器的使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Avro 的 KafkaAvroSerializer 来序列化对象</span></span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>); </span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"io.confluent.kafka.serializers.KafkaAvroSerializer"</span>); </span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"io.confluent.kafka.serializers.KafkaAvroSerializer"</span>);</span><br><span class="line"><span class="comment">// schema.registry.url 是一个新的参数，指向 schema 的存储位置</span></span><br><span class="line">props.put(<span class="string">"schema.registry.url"</span>, schemaUrl);</span><br><span class="line"> </span><br><span class="line">String topic = <span class="string">"customerContacts"</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Customer是生成的对象，这会告诉生产者Customer对象就是记录的值</span></span><br><span class="line">Producer&lt;String, Customer&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, </span><br><span class="line">   Customer&gt;(props);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不断生成事件，直到有人按下Ctrl+C组合键 </span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">    Customer customer = CustomerGenerator.getNext(); </span><br><span class="line">    System.out.println(<span class="string">"Generated customer "</span> + </span><br><span class="line">       customer.toString()); </span><br><span class="line">    <span class="comment">// 实例化一个ProducerRecord对象，并指定Customer为值的类型，然后再传给它一个Customer对象</span></span><br><span class="line">    ProducerRecord&lt;String, Customer&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, customer.getId(), customer);</span><br><span class="line">    producer.send(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><h4 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h4><p>在读取消息之前，需要先创建一个KafkaConsumer对象。创建KafkaConsumer对象与创建KafkaProducer对象非常相似——把想要传给消费者的属性放在Properties对象里。它有3个必要的属性：bootstrap.servers、key.deserializer 和 value.deserializer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. bootstrap.servers</span><br><span class="line">指定集群的连接字符串，与生产者中kafkaProducer用途类似</span><br><span class="line">2. key.deserializer, value.deserializer</span><br><span class="line">与生产者中serializer定义类似，不过是使用指定的类把字节数组转成Java对象</span><br></pre></td></tr></table></figure>

<p>关于创建kafkaConsumer对象，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties(); </span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>); </span><br><span class="line"><span class="comment">// group.id指定了消费者所属群组的名字</span></span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>); </span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>); </span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>); </span><br><span class="line"> </span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</span><br></pre></td></tr></table></figure>

<h4 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h4><p>subscribe()方法接受一个主题列表作为参数，调用它时也可以传入一个正则表达式来匹配订阅多个主题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">"customerCountries"</span>));</span><br><span class="line">consumer.subscribe(<span class="string">"test.*"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>消息轮询通过一个简单的轮询向服务器请求数据。一旦消费者订阅了主题，轮询就会处理所有的细节，包括群组协调、分区再均衡、发送心跳和获取数据，只需要使用一组简单的API来处理从分区返回的数据。消费者代码的主要部分如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 无限循环保证长期运行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 消费者必须持续对kafka进行轮询，否则会被认为已经死亡</span></span><br><span class="line">        <span class="comment">// 传给poll()方法的参数是一个超时时间，用于控制poll()方法的阻塞时间</span></span><br><span class="line">        <span class="comment">// 在指定的100ms内一直等待broker返回数据</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// poll()返回了记录列表</span></span><br><span class="line">        <span class="comment">// 每条记录都包含了记录所属主题的信息、记录所在分区的信息、记录在分区里的偏移量，以及记录的键值对等</span></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123; </span><br><span class="line">            log.debug(<span class="string">"topic = %s, partition = %s, offset = %d, customer = %s, country = %s\n"</span>, </span><br><span class="line">                record.topic(), record.partition(), record.offset(), </span><br><span class="line">                record.key(), record.value()); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> updatedCount = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span> (custCountryMap.countainsValue(record.value())) &#123; </span><br><span class="line">                updatedCount = custCountryMap.get(record.value()) + <span class="number">1</span>; </span><br><span class="line">            &#125; </span><br><span class="line">            custCountryMap.put(record.value(), updatedCount) </span><br><span class="line"></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject(custCountryMap); </span><br><span class="line">            System.out.println(json.toString(<span class="number">4</span>));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">    <span class="comment">// 在退出应用程序之前使用 close() 方法关闭消费者</span></span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h4><p>在必备属性之外</p>
<ol>
<li>fetch.min.bytes</li>
</ol>
<p>该属性指定了消费者从服务器获取记录的最小字节数</p>
<ol start="2">
<li>fetch.max.wait.ms</li>
</ol>
<p>指定 broker 的等待时间，默认是 500ms</p>
<ol start="3">
<li>max.partition.fetch.bytes</li>
</ol>
<p>指定了服务器从每个分区里返回给消费者的最大字节数。它的默认值是 1MB</p>
<ol start="4">
<li>session.timeout.ms</li>
</ol>
<p>指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s</p>
<ol start="5">
<li>auto.offset.reset</li>
</ol>
<p>指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时并被删除）该作何处理。它的默认值是 latest，意思是说，在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）。另一个值是 earliest，意思是说，在偏移量无效的情况下，消费者将从起始位置读取分区的记录。</p>
<ol start="6">
<li>enable.auto.commit</li>
</ol>
<p>指定了消费者是否自动提交偏移量，默认值是 true。为了尽量避免出现重复数据和数据丢失，可以把它设为 false，由自己控制何时提交偏移量</p>
<ol start="7">
<li>partition.assignment.strategy</li>
</ol>
<p>选择分区策略，默认使用的是org.apache.kafka.clients.consumer.RangeAssignor，这个类实现了 Range 策略，不过也可以把它改成 org.apache.kafka.clients.consumer.RoundRobinAssignor</p>
<p>Range: 把主题的若干个连续的分区分配给消费者</p>
<p>roundRobin：把主题的所有分区逐个分配给消费者</p>
<ol start="8">
<li>max.poll.records</li>
</ol>
<p>该属性用于控制单次调用 call() 方法能够返回的记录数量，可以帮你控制在轮询里需要处理的数据量</p>
<ol start="9">
<li>receive.buffer.bytes, send.buffer.bytes</li>
</ol>
<p>socket 在读写数据时用到的 TCP 缓冲区也可以设置大小。如果它们被设为 -1，就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心内，可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kafka/" rel="tag"># kafka</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/31/2019-12-31-spark学习笔记/" rel="next" title="Spark学习笔记">
                <i class="fa fa-chevron-left"></i> Spark学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李子泠</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#background"><span class="nav-number">1.</span> <span class="nav-text">background</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产"><span class="nav-number">2.</span> <span class="nav-text">生产</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者概览"><span class="nav-number">2.1.</span> <span class="nav-text">生产者概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建kafka生产者"><span class="nav-number">2.2.</span> <span class="nav-text">创建kafka生产者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送消息到kafka"><span class="nav-number">2.3.</span> <span class="nav-text">发送消息到kafka</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者的配置"><span class="nav-number">2.4.</span> <span class="nav-text">生产者的配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义序列化器"><span class="nav-number">2.5.</span> <span class="nav-text">自定义序列化器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在Kafka里使用Avro"><span class="nav-number">2.6.</span> <span class="nav-text">在Kafka里使用Avro</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者"><span class="nav-number">3.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建消费者"><span class="nav-number">3.1.</span> <span class="nav-text">创建消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅主题"><span class="nav-number">3.2.</span> <span class="nav-text">订阅主题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轮询"><span class="nav-number">3.3.</span> <span class="nav-text">轮询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消费者的配置"><span class="nav-number">3.4.</span> <span class="nav-text">消费者的配置</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李子泠</span>

  
</div>


  <div class="powered-by">喵</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">
    嗷嗷嗷
  </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
